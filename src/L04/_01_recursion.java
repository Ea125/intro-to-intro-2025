package L04;

public class _01_recursion {
    /*
    * */
    /*
    אחד הקונסטפים הכי מבלבלים בתכנות הם פונקציות רקורסיביות.

    פונקציה רקורסיבית היא פונקציה שקוראת לעצמה.

    אני אוהב להסתכל על פונקציות רקורסיביות כפוקנציה שפותרת בעיה בעזרת 'קסם'.
    אנחנו צריכים לפרק את הבעיה לבעיה קטנה ולפתור את הבעיה הקטנה באמצעות קסם.

    דוגמא קלאסית לפונקציה רקורסיבית היא חישוב עצרת,
    אנחנו מגדירים עצרת ברקורסיה כך:
    עצרת של 0 היא 1
    n! = n * (n-1)!


    f(x) = x = 0 ->  1, x > 0  -> x * f(x - 1)

    כלומר אם נדע לחשב את העצרת של n-1, אז נוכל לחשב את העצרת של n.


    כדי לפתור בעיה באמצעות רקורסיה צריך להבין את הבעיה ולהבין איך לפרק אותה לבעיות קטנות, ומהוא המקרה הבסיס (נגדיר בעצרת ש0! = 1).
     */

    public static int factorial(int n) {
        if (n < 0) {
            return 0;
        }
        if (n == 0) {
            return 1;
        }
        return n * factorial(n - 1);
    }
    /*
    *
    *
    * f(4) *f(3
    * f(5) -> 5 * f(4)
    * */



    /*
    עוד דוגמא ממש מוכרת היא חישוב האיבר ה-n בסדרת פיבונאצ'י.

    סדרת פיבונאצ'י מתחילה ב-0 ו-1 ואיבר כל עת נקבע על ידי סכום האיברים השניים הקודמים.

    כלומר:
    f(0) = 0
    f(1) = 1
    f(n) = f(n-1) + f(n-2)

    אז הסדרה מתחילה כך
    0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...

    אז גם כאן אם נדע לחשב את האיבר ה-n-1 וה-n-2, אז נוכל לחשב את האיבר ה-n.
     */


    public static int fibonacci(int n) {
        if (n == 0) {
            return 0;
        }
        if (n == 1) {
            return 1;
        }

        return fibonacci(n - 1) + fibonacci(n - 2);
        //f(n) -> f(n-1),f(n-2)
        //f(n-1) -> f(n-2),f(n-3)
    }
    public static void main(String[] args) {
        int n = 4;
      //  System.out.println(factorial(n));
     //   System.out.println(factorial(-1));
        System.out.println(fibonacci(n));
    }
}
